package baecon.devgames.model.update;

import android.content.Context;
import android.text.TextUtils;

import com.j256.ormlite.field.DataType;
import com.j256.ormlite.field.DatabaseField;

import java.io.Serializable;

import baecon.devgames.R;
import baecon.devgames.database.modelupdate.EntireModelUpdate;
import baecon.devgames.database.modelupdate.IModelUpdate;
import baecon.devgames.database.modelupdate.Operation;
import baecon.devgames.database.modelupdate.SingleFieldModelUpdate;
import baecon.devgames.model.ISynchronizable;

/**
 * <p>Abstract version of a {@link IModelUpdate}. You only have to implement the {@link IModelUpdate#sync(android.content.Context, baecon.devgames.database.DBHelper, baecon.devgames.connection.client.DevGamesClient)}, which
 * will be executed in a background task {@link baecon.devgames.connection.task.push.ModelPushTask}.</p>
 *
 * @see IModelUpdate
 */
public abstract class AbsModelUpdate<Model extends ISynchronizable> implements
        IModelUpdate<Model>,
        EntireModelUpdate<Model>,
        SingleFieldModelUpdate<Model> {

    public static final class Column {
        public static final String ID = "id";
        public static final String TIMESTAMP = "timestamp";
        public static final String LOCAL_ID = "local_id";
        public static final String MODEL = "model";
        public static final String FIELD = "field"; // would like to use key, but that is a reserved word in SQLite
        public static final String VALUE = "value";
        public static final String NUMBER_OF_RETRIES = "number_of_retries";
        public static final String BLOCKING_ERROR_HTTP_STATUS_CODE = "blocking_error_http_status_code";
        public static final String BLOCKING_ERROR_REASON = "blocking_error_reason";
        public static final String OPERATION = "operation";
    }

    /**
     * Auto-generated ID for this entry
     */
    @DatabaseField(columnName = Column.ID, generatedId = true)
    private long id;

    /**
     * The timestamp when this TaskUpdate was inserted. Used to determine the order of execution of synchronization.
     */
    @DatabaseField(columnName = Column.TIMESTAMP)
    private long timestamp;

    /**
     * The local generated id of the Model
     */
    @DatabaseField(columnName = Column.LOCAL_ID)
    private long uuid;

    /**
     * The serialized model
     */
    @DatabaseField(columnName = Column.MODEL, dataType = DataType.SERIALIZABLE)
    private Model model;

    /**
     * The field of the model that should be updated
     */
    @DatabaseField(columnName = Column.FIELD)
    private String field;

    /**
     * The value that the field should become
 b    */
    @DatabaseField(columnName = Column.VALUE, dataType = DataType.SERIALIZABLE)
    private Serializable value;

    /**
     * The number of attempts that was done to synchronize this update without succeeding.
     */
    @DatabaseField(columnName = Column.NUMBER_OF_RETRIES)
    private int numberOfRetries;

    /**
     *
     */
    @DatabaseField(columnName = Column.BLOCKING_ERROR_HTTP_STATUS_CODE)
    private int blockingErrorHttpStatusCode;

    /**
     *
     */
    @DatabaseField(columnName = Column.BLOCKING_ERROR_REASON)
    private String blockingErrorReason;

    /**
     * The kind of operation
     */
    @DatabaseField(columnName = Column.OPERATION)
    private Operation operation;

    protected AbsModelUpdate() {
        // Empty constructor for ORMLite
    }

    protected AbsModelUpdate(Model model) {
        this(model.getId(), model);
    }

    /**
     * Create an {@link EntireModelUpdate}.
     *  @param id
     *         The local id (that was generated by the local database) for the actual {@link Model}
     * @param model
     *         The instance of the {@link Model} that should be synchronized
     */
    protected AbsModelUpdate(long id, Model model) {
        this.timestamp = System.currentTimeMillis();
        this.id = id;
        this.model = model;
    }

    /**
     * Create a {@link SingleFieldModelUpdate}. Can only be used when he instance of the {@link Model} is known in the
     * back-end (in other words: it has a LOCAL_ID).
     *  @param uuid
     *         The local id (that was generated by the local database) for the actual {@link Model}
     * @param field
     *         The column name of the field that has to be updated
     * @param value
     */
    protected AbsModelUpdate(long uuid, String field, Serializable value) {
        this.timestamp = System.currentTimeMillis();
        this.uuid = uuid;
        this.field = field;
        this.value = value;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void failed() {
        numberOfRetries++;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Model getModel() {
        return model;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getField() {
        return field;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Serializable getValue() {
        return value;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getId() {
        return id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getTimestamp() {
        return timestamp;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public long getLocalId() {
        return uuid;
    }

    /**
     * {@inheritDoc}
     * @param localId
     */
    @Override
    public void setLocalId(long localId) {
        this.uuid = localId;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getNumberOfRetries() {
        return numberOfRetries;
    }

    @Override
    public void setHasBlockingError(int httpStatusCode, String reason) {
        this.blockingErrorHttpStatusCode = httpStatusCode;
        this.blockingErrorReason = reason;
    }

    @Override
    public boolean hasBlockingError() {
        return blockingErrorHttpStatusCode != 0 || blockingErrorReason != null;
    }

    @Override
    public int getBlockingErrorStatusCode() {
        return blockingErrorHttpStatusCode;
    }

    @Override
    public String getBlockingErrorReason() {
        return blockingErrorReason;
    }

    @Override
    public Operation getOperation() {
        return operation;
    }

    @Override
    public void setOperation(Operation operation) {
        this.operation = operation;
    }

    /**
     * Returns a i18n-ized string that can be used in a UI to display the blocking error.
     *
     * @param context Context to access string resources
     *
     * @return a i18n-ized string that can be used in a UI to display the blocking error.
     */
    public String getI18nBlockingErrorForLabel(Context context) {

        boolean hasReason = !TextUtils.isEmpty(blockingErrorReason);
        boolean hasStatusCode = blockingErrorHttpStatusCode != 0;

        // Display the error reason and/or status code, based on which of the two is populated
        if (hasReason && hasStatusCode) {
            return context.getString(R.string.blocking_error_known_with_status_code_known,
                    getBlockingErrorReason(), getBlockingErrorStatusCode());
        }
        else if (hasReason) {
            return context.getString(R.string.blocking_error_known_with_status_code_unknown,
                    getBlockingErrorReason());
        }
        else if (hasStatusCode) {
            return context.getString(R.string.blocking_error_unknown_with_status_code_known,
                    getBlockingErrorStatusCode());
        }
        else {
            return context.getString(R.string.blocking_error_unknown_with_status_code_unknown);
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{" +
                "id=" + id +
                ", timestamp=" + timestamp +
                ", uuid=" + uuid +
                ", model=" + model +
                ", field='" + field + '\'' +
                ", value=" + value +
                ", numberOfRetries=" + numberOfRetries +
                '}';
    }
}