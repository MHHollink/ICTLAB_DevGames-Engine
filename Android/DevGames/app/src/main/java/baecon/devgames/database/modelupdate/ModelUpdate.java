package baecon.devgames.database.modelupdate;

import android.content.Context;

import baecon.devgames.connection.client.DevGamesClient;
import baecon.devgames.database.DBHelper;
import baecon.devgames.model.ISynchronizable;
import retrofit.client.Response;

/**
 * <p>A change to a model class that has to be asynchronously synchronized with the server. In other words, the user
 * does not have to wait until the back-end accepts the change. The UI is only blocked (with a Progress indicator!) when
 * the change is saved to the local database. After that, the user can continue working, while on the background
 * ('asynchronous') the change is synchronized with the back-end.</p>
 *
 * <p>Generally, three things can happen with an update:
 * <ol>
 * <li>
 * The update <strong>succeeds</strong> (which we want as much as possible, of course). In this case, you, and your
 * user, are presumably happy.
 * </li>
 * <li>
 * The update encounters a <strong>recoverable error</strong> during the synchronization to the back-end. In this
 * case, you invoke {@link #failed()} and update this object in the database. A recoverable error is something which
 * is not the fault of the user. When the error is fixed, the update will succeed. For instance, this could be a
 * crappy internet connection, or when the back-end is down for some reason. Just try to sync this update another
 * time.
 * </li>
 * <li>
 * The update encounters an <strong>unrecoverable error</strong>. In this case, the update violates probably some
 * constraint, and the back-end does not allow you to sync this update. When the error is encountered, invoke
 * {@link #setHasBlockingError(int, String)}, so the UI can serve the user some interaction thingy and (s)he can
 * decide what to do with it. You should not retry to sync the update again, as it should always fail.
 * </li>
 * </ol>
 * </p>
 *
 * TODO: assumptions about a model having a .getGeneratedId()
 */
public interface ModelUpdate<Model extends ISynchronizable> {

    /**
     * Returns the id of this update, generated by the database.
     *
     * @return The id of this update, generated by the database.
     */
    long getId();

    /**
     * Returns the time in milliseconds when the update was inserted in the local database.
     *
     * @return The time in milliseconds when the update was inserted in the local database.
     */
    long getTimestamp();

    /**
     * Returns the local database id of the model where this update is related to. This assumes that the model has a
     * generated id in the local database.
     *
     * @return The local database id of the model where this update is related to.
     */
    long getLocalModelId();

    /**
     * Sets the local model id of the model that this update concerns. The local model id is most of the time populated
     * from the local database and in most cases, you don't have to set this.
     *
     * @param localModelId
     *         The generated id for the model
     */
    void setLocalModelId(long localModelId);

    /**
     * Returns the amount of retries that have been attempted to synchronize this update to the back-end. The amount is
     * increased when a synchronization for this update fails.
     * <p>This is not the same as {@link #hasBlockingError()}. This is used when the internet connection or some other
     * recoverable exception happens. The {@link #setHasBlockingError(int, String)} indicates that a non resolvable error
     * occurred.</p>
     *
     * @return The amount of retries that have been attempted to synchronize this update to the back-end.
     */
    int getNumberOfRetries();

    /**
     * Indicate that a synchronization cycle failed. Do not forget to {@link com.j256.ormlite.dao.Dao#refresh(Object)} this object, otherwise
     * it will not be saved.
     * <p>This is not the same as {@link #hasBlockingError()}. This is used when the internet connection or some other
     * recoverable exception happens. The {@link #setHasBlockingError(int, String)} indicates that a non resolvable error
     * occurred.</p>
     */
    void failed();

    /**
     * This is where the actual synchronize call to the back-end is made. Be aware that this method is called from the
     * {@link baecon.devgames.connection.task.RESTTask} from a <b>NON UI-THREAD</b>.
     *
     * @param dbHelper
     *         A DBHelper to get access to the local database
     * @param client
     *         The interface between the app and the back-end
     *
     * @return The {@link retrofit.client.Response} that the call on the {@linkplain DevGamesClient} gave
     */
    Response sync(Context context, DBHelper dbHelper, DevGamesClient client) throws Exception;

    /**
     * Returns a String representation of this ModelUpdate.
     *
     * @return A String representation of this ModelUpdate.
     */
    String toString();

    /**
     * Set whether this update received a blocking error while synchronizing to the back-end. The UI should use this flag
     * to give feedback to the user that updates from this update on could NOT be synchronized. The user might get the
     * choice to throw away all updates after this update, including this update.
     *
     * @param httpStatusCode
     *         The HTPP status code that the back-end gave when it denied the
     * @param reason
     *         An optional reason that was given when the back-end denied this update. May be null.
     *
     * @see #hasBlockingError()
     * @see #setHasBlockingError(int, String)
     * @see #getBlockingErrorStatusCode()
     * @see #getBlockingErrorReason()
     */
    void setHasBlockingError(int httpStatusCode, String reason);

    /**
     * Whether this update received a blocking error while synchronizing to the back-end. The UI should use this flag to
     * give feedback to the user that updates from this update on could NOT be synchronized. The user might get the choice
     * to throw away all updates after this update, including this update.
     *
     * @see #setHasBlockingError(int, String)
     * @see #getBlockingErrorStatusCode()
     * @see #getBlockingErrorReason()
     */
    boolean hasBlockingError();

    /**
     * Returns the HTTP status code that was received when the back-end denied this update.
     *
     * @return The HTTP status code that was received when the back-end denied this update.
     *
     * @see #hasBlockingError()
     * @see #setHasBlockingError(int, String)
     * @see #getBlockingErrorReason()
     */
    int getBlockingErrorStatusCode();

    /**
     * Returns an optional reason that was given when the back-end denied this update. May be null.
     *
     * @return An optional reason that was given when the back-end denied this update. May be null.
     *
     * @see #hasBlockingError()
     * @see #setHasBlockingError(int, String)
     * @see #getBlockingErrorStatusCode()
     */
    String getBlockingErrorReason();
}